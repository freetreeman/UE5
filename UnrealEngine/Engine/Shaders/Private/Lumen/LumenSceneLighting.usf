// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenCardSceneLighting.usf
=============================================================================*/

#include "../Common.ush"
#include "../BRDF.ush"
#include "LumenCardCommon.ush"
#include "LumenCardUpdate.ush"

RWBuffer<uint> RWQuadAllocator;
RWBuffer<uint> RWQuadData;

float4 InfluenceSphere;
float3 LightPosition;
float3 LightDirection;
float LightRadius;
float CosConeAngle;
float SinConeAngle;

void GetCardAABB(FLumenCardData LumenCardData, out float3 WorldCardCenter, out float3 WorldCardExtent)
{
	WorldCardCenter = LumenCardData.Origin;
	WorldCardExtent = mul(abs(LumenCardData.WorldToLocalRotation), LumenCardData.LocalExtent);
}

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 0
#endif

#ifndef SHAPE_TYPE
#define SHAPE_TYPE 0
#endif

uint ScatterInstanceIndex;
uint MaxQuadsPerScatterInstance;

// Resources for LumenCardUpdate
uint NumCardPagesToRenderIndices;
Buffer<uint> CardPagesToRenderIndices;
Buffer<uint> CardPagesToRenderHashMap;

uint FrameId;
float CardLightingUpdateFrequencyScale;
uint CardLightingUpdateMinFrequency;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void CullCardPagesToShapeCS(
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint IndexInIndexBuffer = DispatchThreadId.x;

#if OPERATE_ON_CARD_TILES_MODE == OPERATE_ON_CARD_TILES_TO_RENDER
	if (IndexInIndexBuffer < NumCardPagesToRenderIndices)
	{
		uint CardPageIndex = CardPagesToRenderIndices[IndexInIndexBuffer];
#else
	if (IndexInIndexBuffer < LumenCardScene.NumCardPages)
	{
		uint CardPageIndex = IndexInIndexBuffer;
#endif
		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex);
		if (CardPage.CardIndex >= 0)
		{
			FLightCullingParameters LightCullingParameters = CreateLightCullingParameters(
				InfluenceSphere, LightPosition, LightDirection, LightRadius, CosConeAngle, SinConeAngle);

			FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);

			FLumenCardUpdateResources CardUpdateResources = CreateLumenCardUpdateResources(
				NumCardPagesToRenderIndices, CardPagesToRenderIndices, CardPagesToRenderHashMap);

			FLumenCardUpdateOptions CardUpdateOptions = CreateLumenCardUpdateOptions(
				CardLightingUpdateMinFrequency, CardLightingUpdateFrequencyScale, FrameId);

			if (Card.bVisible
				&& DoesLightAffectCardPage(SHAPE_TYPE, LightCullingParameters, CardPage, Card)
				&& ShouldUpdateCardPage(CardPageIndex, Card, CardUpdateResources, CardUpdateOptions))
			{
				uint QuadDataInsertIndex;
				InterlockedAdd(RWQuadAllocator[ScatterInstanceIndex], 1, QuadDataInsertIndex);

				QuadDataInsertIndex += MaxQuadsPerScatterInstance * ScatterInstanceIndex;

				uint Packed = CardPageIndex;
				RWQuadData[QuadDataInsertIndex] = Packed;
			}
		}
	}
}

Buffer<uint> QuadAllocator;
RWBuffer<uint> RWCardIndirectArgs;

uint TilesPerInstance;
uint MaxScatterInstanceCount;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void InitializeCardScatterIndirectArgsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ScatterInstanceIndex = DispatchThreadId.x;

	if (ScatterInstanceIndex < MaxScatterInstanceCount)
	{
		// sizeof(FRHIDrawIndexedIndirectParameters) / sizeof(uint32) == 5
		uint ArgOffset = ScatterInstanceIndex * 5;
		uint NumQuads = QuadAllocator[ScatterInstanceIndex];

		#if RECT_LIST_TOPOLOGY
		{
			// VertexCountPerInstance, InstanceCount, StartVertexLocation, StartInstanceLocation
			RWCardIndirectArgs[0 + ArgOffset] = 4 * TilesPerInstance;
			RWCardIndirectArgs[1 + ArgOffset] = (NumQuads + TilesPerInstance - 1) / TilesPerInstance;
			RWCardIndirectArgs[2 + ArgOffset] = 0;
			RWCardIndirectArgs[3 + ArgOffset] = 0;
		}
		#else
		{
			// IndexCount, NumInstances, StartIndex, BaseVertexIndex, FirstInstance
			RWCardIndirectArgs[0 + ArgOffset] = 6 * TilesPerInstance;
			RWCardIndirectArgs[1 + ArgOffset] = (NumQuads + TilesPerInstance - 1) / TilesPerInstance;
			RWCardIndirectArgs[2 + ArgOffset] = 0;
			RWCardIndirectArgs[3 + ArgOffset] = 0;
			RWCardIndirectArgs[4 + ArgOffset] = 0;
		}
		#endif
	}
}

Buffer<uint> QuadData;
float2 DownsampledInputAtlasSize;

Buffer<uint4> RectMinMaxBuffer;
float2 InvRectMinMaxResolution;

void RasterizeToCardsVS(
	float2 TexCoord : ATTRIBUTE0,
	uint VertexId : SV_VertexID,
	uint InstanceId : SV_InstanceID, 
	out FCardVSToPS CardInterpolants,
	out float4 OutPosition : SV_POSITION
	)
{
	// Compute the actual instance id for when multiple tiles are packed into the vertex buffer
	uint EffectiveInstanceId = InstanceId * TilesPerInstance + VertexId / 4;

	uint BaseQuadOffset = MaxQuadsPerScatterInstance * ScatterInstanceIndex;
	uint NumQuads = QuadAllocator[ScatterInstanceIndex];

	CardInterpolants = (FCardVSToPS)0;
	OutPosition = 0;

	if (EffectiveInstanceId < NumQuads)
	{
		uint QuadIndex = EffectiveInstanceId + BaseQuadOffset;
		uint CardPageIndex = QuadData[QuadIndex];
		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex);
		FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);

		#if CLAMP_TO_INFLUENCE_SPHERE
		{
			float3 LocalSphereOrigin = mul(InfluenceSphere.xyz - Card.Origin, Card.WorldToLocalRotation);

			float2 InvCardPageUVSize = 1.0f / (CardPage.CardUVRect.zw - CardPage.CardUVRect.xy);

			float2 SphereOriginCardUV = SamplePositonToCardUV(Card, LocalSphereOrigin.xy);
			float2 SphereOriginCardPageUV = (SphereOriginCardUV - CardPage.CardUVRect.xy) * InvCardPageUVSize;

			float2 SphereRadius = 0.5f * (InfluenceSphere.ww / Card.LocalExtent.xy) * InvCardPageUVSize;

			TexCoord = clamp(TexCoord, SphereOriginCardPageUV - SphereRadius, SphereOriginCardPageUV + SphereRadius);
		}
		#endif

		float2 ScreenUV = lerp(CardPage.PhysicalAtlasUVRect.xy, CardPage.PhysicalAtlasUVRect.zw, TexCoord);
		float2 AtlasUV = ScreenUV;

		#if RECT_BUFFER_SRC
		{
			float4 AtlasUVRect = RectMinMaxBuffer[CardPageIndex].xyzw * InvRectMinMaxResolution.xyxy;
			AtlasUV = lerp(AtlasUVRect.xy, AtlasUVRect.zw, TexCoord);
		}
		#endif

		#if RECT_BUFFER_SRC
		{
			float4 AtlasUVRect = RectMinMaxBuffer[QuadIndex].xyzw * InvRectMinMaxResolution.xyxy;
			ScreenUV = lerp(AtlasUVRect.xy, AtlasUVRect.zw, TexCoord);
		}
		#endif

		// When sampling from a downsampled atlas we need to appropriately clamp input UVs to prevent bilinear reading outside of the valid area
		if (DownsampledInputAtlasSize.x > 0.0f)
		{
			float2 CardWidthInTexels = (CardPage.PhysicalAtlasUVRect.zw - CardPage.PhysicalAtlasUVRect.xy) * DownsampledInputAtlasSize;
			float2 ClampBorder = 0.5f / CardWidthInTexels;

			TexCoord = clamp(TexCoord, ClampBorder, 1.0f - ClampBorder);
			AtlasUV = lerp(CardPage.PhysicalAtlasUVRect.xy, CardPage.PhysicalAtlasUVRect.zw, TexCoord);
		}

		float2 ScreenPosition = float2(2.0f, -2.0f) * ScreenUV + float2(-1.0f, 1.0f);
		OutPosition = float4(ScreenPosition, 0, 1);

		float2 QuadCorner = -2.0f * TexCoord + 1.0f;
		CardInterpolants.AtlasUV = AtlasUV;
		CardInterpolants.CardUV = lerp(CardPage.CardUVRect.xy, CardPage.CardUVRect.zw, TexCoord);
		CardInterpolants.CardPageIndex = CardPageIndex;
	}
}

Texture2D RadiosityAtlas;
Texture2D OpacityAtlas;

void LumenCardLightingInitializePS(
	FCardVSToPS CardInterpolants,
	out float4 OutColor : SV_Target0)
{   
	float3 Radiosity = Texture2DSampleLevel(RadiosityAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasUV, 0).xyz;
	
	// Secure again strange values, as we are writing it to a persistent atlas with a feedback loop
	Radiosity = max(MakeFinite(Radiosity), float3(0.0f, 0.0f, 0.0f));
	OutColor = float4(Radiosity, 0);
}

Texture2D SrcAtlas;

void LumenCardCopyAtlasPS(
	FCardVSToPS CardInterpolants,
	out float4 OutValue : SV_Target0)
{
	float3 Value = Texture2DSampleLevel(SrcAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasUV, 0).xyz;
	OutValue = float4(Value, 0);
}

Texture2D AlbedoAtlas;
Texture2D EmissiveAtlas;
float DiffuseReflectivityOverride;

void LumenCardBlendAlbedoPS(
	FCardVSToPS CardInterpolants,
	out float4 OutColor0 : SV_Target0,
	out float4 OutColor1 : SV_Target1)
{
	float3 AlbedoSqr = Texture2DSampleLevel(AlbedoAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasUV, 0).xyz;
	float3 DiffuseColor = AlbedoSqr * AlbedoSqr;

	if (DiffuseReflectivityOverride > 0.0f)
	{
		float DiffuseMaxComponent = max(DiffuseColor.r, max(DiffuseColor.g, DiffuseColor.b));
		DiffuseColor = saturate(DiffuseColor * max(DiffuseReflectivityOverride / max(DiffuseMaxComponent, .0001f), 1.0f));
	}

	float3 Emissive = Texture2DSampleLevel(EmissiveAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasUV, 0).xyz;
	OutColor0 = float4(Emissive, 0);
	OutColor1 = float4(Diffuse_Lambert(DiffuseColor), 0);
}

void ClearLumenCardsPS(
	out float4 OutAlbedo : SV_Target0,
	out float4 OutNormals : SV_Target1,
	out float4 OutEmissive : SV_Target2
)
{
	OutAlbedo = float4(0.0f, 0.0f, 0.0f, 0.0f);
	OutNormals = float4(0.5f, 0.5f, 0.0f, 0.0f);
	OutEmissive = float4(0.0f, 0.0f, 0.0f, 0.0f);
}