// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenCardCommon.ush
=============================================================================*/

#pragma once

#include "../OctahedralCommon.ush"

struct FLumenCardData
{
	float3x3 WorldToLocalRotation;
	float3 Origin;
	float3 LocalExtent;

	uint2 SizeInPages;
	uint PageTableOffset;

	uint2 HiResSizeInPages;
	uint HiResPageTableOffset;

	// Convert Card's uint ResLevel (card's resolution) to uint2 ResLevelXY (each side's resolution)
	uint2 ResLevelToResLevelXYBias;

	bool bVisible;
};

// Stride of a single cards's data in float4's, must match C++
#define PROXY_CARD_DATA_STRIDE 5
#define LUMEN_CARD_TILE_DATA_STRIDE 3

void GetLumenCardSharedDataInternal(uint BaseOffset, StructuredBuffer<float4> CardBuffer, inout FLumenCardData CardData)
{
	// Note: layout must match FLumenCardData in C++
	// Relying on optimizer to remove unused loads

	CardData = (FLumenCardData)0;

	float4 Vector0 = CardBuffer[BaseOffset + 0];
	float4 Vector1 = CardBuffer[BaseOffset + 1];
	float4 Vector2 = CardBuffer[BaseOffset + 2];
	float4 Vector3 = CardBuffer[BaseOffset + 3];
	float4 Vector4 = CardBuffer[BaseOffset + 4];

	CardData.WorldToLocalRotation[0] = Vector0.xyz;
	CardData.WorldToLocalRotation[1] = Vector1.xyz;
	CardData.WorldToLocalRotation[2] = Vector2.xyz;
	CardData.Origin = float3(Vector0.w, Vector1.w, Vector2.w);

	CardData.LocalExtent = abs(Vector3.xyz);
	CardData.ResLevelToResLevelXYBias.x = (asuint(Vector3.w) >> 0) & 0xFF;
	CardData.ResLevelToResLevelXYBias.y = (asuint(Vector3.w) >> 8) & 0xFF;
	CardData.bVisible = asuint(Vector3.w) & (1 << 16);

	CardData.SizeInPages.x = (asuint(Vector4.x) >> 0) & 0xFFFF;
	CardData.SizeInPages.y = (asuint(Vector4.x) >> 16) & 0xFFFF;
	CardData.PageTableOffset = asuint(Vector4.y);
	CardData.HiResSizeInPages.x = (asuint(Vector4.z) >> 0) & 0xFFFF;
	CardData.HiResSizeInPages.y = (asuint(Vector4.z) >> 16) & 0xFFFF;
	CardData.HiResPageTableOffset = asuint(Vector4.w);
}

bool IsCardVisible(uint CardId)
{
	return LumenCardScene.CardData[CardId * PROXY_CARD_DATA_STRIDE + 3].y > 0.0f;
}

// Fetch from scene card buffer
FLumenCardData GetLumenCardData(uint CardId) 
{
	FLumenCardData CardData;
	uint BaseOffset = CardId * PROXY_CARD_DATA_STRIDE;
	
	GetLumenCardSharedDataInternal(BaseOffset, LumenCardScene.CardData, CardData);

	return CardData;
}

FLumenCardData GetLumenCardData(uint CardId, StructuredBuffer<float4> CardBuffer) 
{
	FLumenCardData CardData;
	uint BaseOffset = CardId * PROXY_CARD_DATA_STRIDE;
	
	GetLumenCardSharedDataInternal(BaseOffset, CardBuffer, CardData);

	return CardData;
}

struct FLumenCardPageData
{
	uint CardIndex;
	float4 CardUVRect;
	float4 PhysicalAtlasUVRect;
};

void GetLumenCardPageInternal(uint BaseOffset, StructuredBuffer<float4> CardPageBuffer, inout FLumenCardPageData CardPageData)
{
	// Note: layout must match FLumenCardPageData in C++

	CardPageData = (FLumenCardPageData) 0;

	float4 Vector0 = CardPageBuffer[BaseOffset + 0];
	float4 Vector1 = CardPageBuffer[BaseOffset + 1];
	float4 Vector2 = CardPageBuffer[BaseOffset + 2];

	CardPageData.CardIndex = asuint(Vector0.x);
	CardPageData.CardUVRect = Vector1;
	CardPageData.PhysicalAtlasUVRect = Vector2;
}

// Fetch from scene card buffer
FLumenCardPageData GetLumenCardPageData(uint CardPageId)
{
	FLumenCardPageData CardPageData;
	uint BaseOffset = CardPageId * LUMEN_CARD_TILE_DATA_STRIDE;

	GetLumenCardPageInternal(BaseOffset, LumenCardScene.CardPageData, CardPageData);

	return CardPageData;
}

FLumenCardPageData GetLumenCardPageData(uint CardPageId, StructuredBuffer<float4> CardPageBuffer)
{
	FLumenCardPageData CardPageData;
	uint BaseOffset = CardPageId * LUMEN_CARD_TILE_DATA_STRIDE;

	GetLumenCardPageInternal(BaseOffset, CardPageBuffer, CardPageData);

	return CardPageData;
}

float3 TransformLocalToAxis(uint AxisIndex, float3 LocalPosition)
{
	// Local to Axis
	// 0: xyz = x, y, z
	// 1: xyz = z, y, -x
	// 2: xyz = x, -z, y
	// Note: must match C++ FCardRenderData::GetWorldToLocalRotation

	float3 FacePosition = LocalPosition;

	if (AxisIndex == 1)
	{
		FacePosition = float3(FacePosition.zy, -FacePosition.x);
	}
	else if (AxisIndex == 2)
	{		
		FacePosition = float3(FacePosition.x, -FacePosition.z, FacePosition.y);
	}

	return FacePosition;
}

float3 TransformFaceToLocal(uint FaceIndex, float3 FacePosition)
{
	if (FaceIndex & 1)
	{
		FacePosition.yz = -FacePosition.yz;
	}

	float3 LocalPosition = FacePosition;

	// Axis to Local
	// 0: xyz = x, y, z
	// 1: xyz = -z, y, x
	// 2: xyz = x, z, -y
	// Note: must match C++ FCardRenderData::GetWorldToLocalRotation

	uint AxisIndex = FaceIndex / 2;

	if (AxisIndex == 1)
	{
		LocalPosition = float3(-FacePosition.z, FacePosition.y, FacePosition.x);
	}
	else if (AxisIndex == 2)
	{		
		LocalPosition = float3(FacePosition.x, FacePosition.z, -FacePosition.y);
	}

	return LocalPosition;
}

struct FCardVSToPS
{
	float2 AtlasUV : ATTRIBUTE0;
	float2 CardUV : ATTRIBUTE1;
	nointerpolation uint CardPageIndex : CARD_ID;
};

// Stride of mesh cards data, must match C++
#define LUMEN_MESH_CARDS_DATA_STRIDE 4
#define LUMEN_INVALID_CARD_INDEX 0xFFFFFFFF

struct FLumenMeshCardsData
{
	float4x4 WorldToLocal;

	// Per orientation
	uint NumCards[6];
	uint CardOffset[6];
};

void UnpackCardNumAndOffset(inout uint NumCards, inout uint CardOffset, uint BaseCardOffset, uint PackedData, uint PackedDataOffset)
{
	NumCards = (PackedData >> (PackedDataOffset + 0)) & 0xFF;
	CardOffset = (PackedData >> (PackedDataOffset + 8)) & 0xFF;

	CardOffset += BaseCardOffset;
}

// Note: layout must match FLumenMeshCardsData in C++
FLumenMeshCardsData GetLumenMeshCardsData(uint MeshCardsId)
{
	uint BaseOffset = MeshCardsId * LUMEN_MESH_CARDS_DATA_STRIDE;

	FLumenMeshCardsData MeshCardsData;

	float4 M0 = LumenCardScene.MeshCardsData[BaseOffset + 0];
	float4 M1 = LumenCardScene.MeshCardsData[BaseOffset + 1];
	float4 M2 = LumenCardScene.MeshCardsData[BaseOffset + 2];
	MeshCardsData.WorldToLocal = transpose(float4x4(M0, M1, M2, float4(0.0f, 0.0f, 0.0f, 1.0f)));

	uint4 PackedData;
	PackedData.x = asuint(LumenCardScene.MeshCardsData[BaseOffset + 3].x);
	PackedData.y = asuint(LumenCardScene.MeshCardsData[BaseOffset + 3].y);
	PackedData.z = asuint(LumenCardScene.MeshCardsData[BaseOffset + 3].z);
	PackedData.w = asuint(LumenCardScene.MeshCardsData[BaseOffset + 3].w);

	uint BaseCardOffset = PackedData.w;

	UnpackCardNumAndOffset(MeshCardsData.NumCards[0], MeshCardsData.CardOffset[0], BaseCardOffset, PackedData.x, 0);
	UnpackCardNumAndOffset(MeshCardsData.NumCards[1], MeshCardsData.CardOffset[1], BaseCardOffset, PackedData.x, 16);
	UnpackCardNumAndOffset(MeshCardsData.NumCards[2], MeshCardsData.CardOffset[2], BaseCardOffset, PackedData.y, 0);
	UnpackCardNumAndOffset(MeshCardsData.NumCards[3], MeshCardsData.CardOffset[3], BaseCardOffset, PackedData.y, 16);
	UnpackCardNumAndOffset(MeshCardsData.NumCards[4], MeshCardsData.CardOffset[4], BaseCardOffset, PackedData.z, 0);
	UnpackCardNumAndOffset(MeshCardsData.NumCards[5], MeshCardsData.CardOffset[5], BaseCardOffset, PackedData.z, 16);

	return MeshCardsData;
}

float3 GetCardLocalPosition(FLumenCardData Card, float2 CardUV, float Depth)
{
	CardUV.x = 1.0f - CardUV.x;

	float3 LocalPosition;
	LocalPosition.xy = Card.LocalExtent.xy * (1.0f - 2.0f * CardUV);
	LocalPosition.z = -Card.LocalExtent.z + Depth * 2.0f * Card.LocalExtent.z;

	return LocalPosition;
}

void GetCardLocalBBox(FLumenCardPageData CardPage, FLumenCardData Card, float2 UVMin, float2 UVMax, out float3 CardPageLocalCenter, out float3 CardPageLocalExtent)
{
	float2 CardUVMin = lerp(CardPage.CardUVRect.xw, CardPage.CardUVRect.zy, UVMin);
	float2 CardUVMax = lerp(CardPage.CardUVRect.xw, CardPage.CardUVRect.zy, UVMax);
	float3 CardPageLocalBoxMin = GetCardLocalPosition(Card, CardUVMin, 0.0f);
	float3 CardPageLocalBoxMax = GetCardLocalPosition(Card, CardUVMax, 1.0f);

	CardPageLocalCenter = 0.5f * (CardPageLocalBoxMax + CardPageLocalBoxMin);
	CardPageLocalExtent = 0.5f * (CardPageLocalBoxMax - CardPageLocalBoxMin);
}

void GetCardPageLocalBBox(FLumenCardPageData CardPage, FLumenCardData Card, out float3 CardPageLocalCenter, out float3 CardPageLocalExtent)
{
	GetCardLocalBBox(CardPage, Card, 0, 1, CardPageLocalCenter, CardPageLocalExtent);
}

float3 GetCardWorldPosition(FLumenCardData Card, float2 CardUV, float Depth)
{
	float3 LocalPosition = GetCardLocalPosition(Card, CardUV, Depth);
	float3 WorldPosition = mul(Card.WorldToLocalRotation, LocalPosition) + Card.Origin;
	return WorldPosition;
}

uint2 GetCardPageSizeInTexels(FLumenCardPageData CardPage, uint2 AtlasSize)
{
	float2 AtlasSizeInUV = CardPage.PhysicalAtlasUVRect.zw - CardPage.PhysicalAtlasUVRect.xy;
	return uint2(AtlasSizeInUV * AtlasSize);
}

float2 CardPageUVToCardUV(FLumenCardPageData CardPage, float2 CardPageUV)
{
	float2 CardUV = lerp(CardPage.CardUVRect.xy, CardPage.CardUVRect.zw, CardPageUV);
	return CardUV;
}

float2 CardPageUVToAtlasUV(FLumenCardPageData CardPage, float2 CardPageUV)
{
	float2 AtlasUV = lerp(CardPage.PhysicalAtlasUVRect.xy, CardPage.PhysicalAtlasUVRect.zw, CardPageUV);
	return AtlasUV;
}

float2 SamplePositonToCardUV(FLumenCardData Card, float2 LocalSamplePosition)
{
	float2 CardUV = saturate(float2(+0.5f, -0.5f) * (LocalSamplePosition / Card.LocalExtent.xy) + 0.5f);
	return CardUV;
}

// Return decoded world space normal
float3 DecodeSurfaceCacheNormal(FLumenCardData Card, float2 EncodedNormal)
{
	float3 CardSpaceNormal;
	CardSpaceNormal.xy = EncodedNormal.xy * 2.0f - 1.0f;
	CardSpaceNormal.z = sqrt(max(1.0f - length2(CardSpaceNormal.xy), 0.0001f));
	return mul(Card.WorldToLocalRotation, CardSpaceNormal);
}

bool SphereIntersectCone(float4 SphereCenterAndRadius, float3 ConeVertex, float3 ConeAxis, float ConeAngleCos, float ConeAngleSin)
{
	float3 U = ConeVertex - (SphereCenterAndRadius.w / ConeAngleSin) * ConeAxis;
	float3 D = SphereCenterAndRadius.xyz - U;
	float DSizeSq = dot(D, D);
	float E = dot(ConeAxis, D);

	if (E > 0 && E * E >= DSizeSq * ConeAngleCos * ConeAngleCos)
	{
		D = SphereCenterAndRadius.xyz - ConeVertex;
		DSizeSq = dot(D, D);
		E = -dot(ConeAxis, D);

		if (E > 0 && E * E >= DSizeSq * ConeAngleSin * ConeAngleSin)
		{
			return DSizeSq <= SphereCenterAndRadius.w * SphereCenterAndRadius.w;
		}
		else
		{
			return true;
		}
	}

	return false;
}

struct FLightCullingParameters
{
	float4 InfluenceSphere;
	float3 LightPosition;
	float3 LightDirection;
	float LightRadius;
	float CosConeAngle;
	float SinConeAngle;
};

FLightCullingParameters CreateLightCullingParameters(
	float4 InfluenceSphere,
	float3 LightPosition,
	float3 LightDirection,
	float LightRadius,
	float CosConeAngle,
	float SinConeAngle
)
{
	FLightCullingParameters Parameters;
	Parameters.InfluenceSphere = InfluenceSphere;
	Parameters.LightPosition = LightPosition;
	Parameters.LightDirection = LightDirection;
	Parameters.LightRadius = LightRadius;
	Parameters.CosConeAngle = CosConeAngle;
	Parameters.SinConeAngle = SinConeAngle;

	return Parameters;
}

bool DoesLightAffectCard(uint LightType, FLightCullingParameters LightCullingParameters, FLumenCardPageData CardPage, FLumenCardData Card, float2 UVMin, float2 UVMax)
{
	float3 CardPageLocalCenter;
	float3 CardPageLocalExtent;
	GetCardLocalBBox(CardPage, Card, UVMin, UVMax, CardPageLocalCenter, CardPageLocalExtent);

	float3 CardPageWorldCenter = mul(Card.WorldToLocalRotation, CardPageLocalCenter) + Card.Origin;
	float3 CardPageWorldExtent = mul(abs(Card.WorldToLocalRotation), CardPageLocalExtent);
	float CardPageWorldBoundingSphere = length(CardPageLocalExtent);

	float4 InfluenceSphere = LightCullingParameters.InfluenceSphere;
	float3 LightInfluenceSphereLocalCenter = mul(InfluenceSphere.xyz - Card.Origin, Card.WorldToLocalRotation);
	const float BoxDistanceSq = ComputeSquaredDistanceFromBoxToPoint(CardPageLocalCenter, CardPageLocalExtent, LightInfluenceSphereLocalCenter);
	const bool bCardAffectedByInfluenceSphere = BoxDistanceSq < InfluenceSphere.w* InfluenceSphere.w;

	//uint LightType = LightCullingParameters.GetLightType();
	if (LightType == 0)
	{
		return true;
	}
	else if (LightType == 1)
	{
		// Point light
		return bCardAffectedByInfluenceSphere;
	}
	else if (LightType == 2)
	{
		float3 LightPosition = LightCullingParameters.LightPosition;
		float3 LightDirection = LightCullingParameters.LightDirection;
		float CosConeAngle = LightCullingParameters.CosConeAngle;
		float SinConeAngle = LightCullingParameters.SinConeAngle;
		float LightRadius = LightCullingParameters.LightRadius;

		float ConeAxisDistance = dot(CardPageWorldCenter - LightPosition, LightDirection);
		float2 ConeAxisDistanceMinMax = float2(ConeAxisDistance + CardPageWorldBoundingSphere, ConeAxisDistance - CardPageWorldBoundingSphere);

		// Spot light
		return bCardAffectedByInfluenceSphere
			&& SphereIntersectCone(float4(CardPageWorldCenter, CardPageWorldBoundingSphere), LightPosition, LightDirection, CosConeAngle, SinConeAngle)
			&& ConeAxisDistanceMinMax.x > 0 && ConeAxisDistanceMinMax.y < LightRadius;
	}
	else if (LightType == 3)
	{
		float3 LightPosition = LightCullingParameters.LightPosition;
		float3 LightDirection = LightCullingParameters.LightDirection;

		// Rect light
		float4 BackPlane = float4(LightDirection, dot(LightPosition, LightDirection));
		float DistanceFromBoxCenterToPlane = dot(BackPlane.xyz, CardPageWorldCenter) - BackPlane.w;
		float MaxExtent = dot(CardPageWorldExtent, abs(BackPlane.xyz));
		bool bInFrontOfPlane = DistanceFromBoxCenterToPlane + MaxExtent > 0.0f;
		return bCardAffectedByInfluenceSphere && bInFrontOfPlane;
	}

	// Error: Unknown light type
	return false;
}

bool DoesLightAffectCardPage(uint LightType, FLightCullingParameters LightCullingParameters, FLumenCardPageData CardPage, FLumenCardData Card)
{
	float2 UVMin = 0;
	float2 UVMax = 1;
	return DoesLightAffectCard(LightType, LightCullingParameters, CardPage, Card, UVMin, UVMax);
}

float3 GetCardWorldPositionForShadowing(float3 WorldPosition, float3 L, float3 WorldNormal, float SurfaceBias, float SlopeScaledSurfaceBias, float BiasScale)
{
	//@todo DynamicGI - derive from card texel size
	return WorldPosition + L * (SurfaceBias + SlopeScaledSurfaceBias * saturate(1 - dot(L, WorldNormal))) * BiasScale;
}