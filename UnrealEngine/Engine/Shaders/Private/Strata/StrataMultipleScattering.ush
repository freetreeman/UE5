// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once 

#include "/Engine/Private/Common.ush"

// this multiple scattering implementation is based on "Practical multiple scattering compensation for microfacet models." E. Turquin

// Multiple scattering computation use a precomputed LUT. There are two variant: 
//  1) Using 2D LUT using Schlick Fresnel decomposition (view angle, roughness)
//  2) Using 3D LUT building a full 3D LUT (view angle, roughness, F0)

struct FStrataGGXDirectionalAlbedo
{
	float3 SpecularR;		// Specular Directional albedo with multiple scattering (reflection)
	float3 SpecularT;		// Specular Directional albedo with multiple scattering (transmission)
	float3 SpecularTChan;	// Specular Directional albedo with multiple scattering (transmission) for the Chan model which has a hardcoded F0=0.04 for the diffuse interactions
	float3 Diffuse;			// Diffuse  Directional albedo with multiple scattering (embedded into Chan's model itself)
};

struct FStrataGGXLUTResult
{
	// Fresnel A/B term for reconstructing directional albedo for reflection (used to evaluate a chromatic specular reflectance). These values are dependent of F0.
	float A_R;
	float B_R;

	// Complete directional albedo for reflection, refraction, and diffuse (used to evluate an achromatic specular reflectance). These values are independent of F0
	float E_R;
	float E_T;
	float E_D;

	float E_TChan;

	// Derived terms
	float3 SpecularMultipleScatteringScale;			// Multiple scattering scale factor for specular reflection
	FStrataGGXDirectionalAlbedo DirectionalAlbedo;	// Directional albedo (with multiple scattering for reflection/transmission/diffuse
};

// Return the directional albedo of a specular GGX interface for reflection term without multiple scattering
float3 StrataEvaluateSpecularGGXDirectionalAlbedo(float3 F0, float3 F90, FStrataGGXLUTResult LUT)
{
	// Reconstruction of the directional Albedo for upper hemisphere
	// E_R = F0.A_R + (1-F0).B_R
	return F0 * LUT.A_R + (F90 - F0) * LUT.B_R;
}

// Return a scaling factor to multiply a specular GGX interface with, to add multiple scattering contribution (for conductor)
float3 StrataEvaluateMultipleScatteringConductor(float3 F0, float3 F90, FStrataGGXLUTResult LUT)
{
	// Microfacet multiple scattering term for *conductor*
	//  f_ms(wo,wi) = F_ss . (1 +  F0 (1-E_R)/ E_R)

	const float3 E_R = StrataEvaluateSpecularGGXDirectionalAlbedo(F0, F90, LUT);
	const float3 Safe_E_R = max(1e-8f, E_R);	// the threshold making E_R safe is lower than any of the non-zero values in the current LUT
	return (1 + F0 * (1 - E_R) / Safe_E_R);
}

// Return a scaling factor to multiple a specular GGX interface with, to add multiple scattering contribution (for dieletric)
float3 StrataEvaluateMultipleScatteringDielectric(FStrataGGXLUTResult LUT)
{
	// Microfacet multiple scattering term for *dieletric*
	//  f_ms(wo,wi) = F_ss / (E_T + E_R)

	return 1.f / (LUT.E_R + LUT.E_T);
}

// Return the directional alebedo of a diffuse GGX interface without multiple scattering
float3 StrataEvaluateDiffuseGGXDirectionalAlbedo(float3 Albedo, FStrataGGXLUTResult LUT)
{
	return Albedo * LUT.E_D;
}

FStrataGGXLUTResult StrataSampleGGXLUT(Texture2D<float4> LUT2D, Texture3D<float3> LUT3D, SamplerState LUTSampler, float2 LUTScaleBias, float NoV, float RoughnessX, float RoughnessY, float3 F0, float3 F90, float Metallic, float3 DiffuseAlbedo)
{
	// Use the main Roughness term to drive the energy compensation.
	// "Revisiting Physically Based Shading at Imageworks" Kulla 2017
	const float LUTRoughness = RoughnessX;

	// LUTF0 is used for dieletric directional albedo/multiple scattering, so we expect this terms to be mostly achromatic. If it happens it is not, then we use the max component of the LUT lookup
	const float LUTF0 = saturate(max(max(F0.x, F0.y), F0.z));

	FStrataGGXLUTResult Out = (FStrataGGXLUTResult)0;

	// 2D LUT sampling
	{
		const float2 UV = float2(saturate(NoV), saturate(LUTRoughness)) * LUTScaleBias.x + LUTScaleBias.yy;
		const float4 S = LUT2D.SampleLevel(LUTSampler, UV, 0);
		Out.A_R = S.x;
		Out.B_R = S.y;
		Out.E_D = S.z;
	}

	// 3D LUT sampling
	{
		const float3 UVW = float3(saturate(NoV), saturate(LUTRoughness), LUTF0) * LUTScaleBias.x + LUTScaleBias.yyy;
		const float3 S = LUT3D.SampleLevel(LUTSampler, UVW, 0);
		Out.E_R = S.x;
		Out.E_T = S.y;
		Out.E_TChan = S.z;
	}

	// Derived MS scales
	{
		const float3 DA_ConductorSS = StrataEvaluateSpecularGGXDirectionalAlbedo(F0, F90, Out);

		const float3 MSScale_Dieletric = StrataEvaluateMultipleScatteringDielectric(Out);
		const float3 MSScale_Conductor = StrataEvaluateMultipleScatteringConductor(F0, F90, Out);
		const float3 MSScale		   = lerp(MSScale_Dieletric, MSScale_Conductor, Metallic);

		Out.SpecularMultipleScatteringScale = MSScale;
		Out.DirectionalAlbedo.SpecularR		= MSScale * lerp(Out.E_R.xxx, DA_ConductorSS, Metallic);
		Out.DirectionalAlbedo.SpecularT		= MSScale * lerp(Out.E_T, 0.f, Metallic);
		Out.DirectionalAlbedo.SpecularTChan	= MSScale * lerp(Out.E_TChan, 0.f, Metallic);
		Out.DirectionalAlbedo.Diffuse		= StrataEvaluateDiffuseGGXDirectionalAlbedo(DiffuseAlbedo, Out);
	}
	return Out;
}