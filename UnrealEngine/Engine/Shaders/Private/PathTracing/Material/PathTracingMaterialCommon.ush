// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
PathTracingMaterialCommon.usf: Brdf utility functions
===============================================================================================*/

#pragma once

#include "../PathTracingCommon.ush"
#include "/Engine/Private/BRDF.ush"

// Given two lobes that will roughly contribute colors A and B to the total (estimated for example using directional albedo)
// return the probability of choosing lobe A
float LobeSelectionProb(float3 A, float3 B)
{
	const float SumA = A.x + A.y + A.z;
	const float SumB = B.x + B.y + B.z;
	return SumA / (SumA + SumB + 1e-6);
}

// Takes as input the sample weight and pdf for a certain lobe of a mixed model, together with the probability of picking that lobe
// This function then updates a running total Weight and Pdf value that represents the overall contribution of the BxDF
// This function should be called when a BxDF is made up of multiple lobes combined with a sum to correctly account for the probability
// of sampling directions via all lobes.
// NOTE: this function also contains special logic to handle cases with infinite pdfs cleanly
void AddLobeWithMIS(inout float3 Weight, inout float Pdf, float3 LobeWeight, float LobePdf, float LobeProb)
{
	const float MinLobeProb = 1.1754943508e-38; // smallest normal float
	if (LobeProb > MinLobeProb)
	{
		LobePdf *= LobeProb;
		LobeWeight *= 1 / LobeProb;

		// See discussion in MISWeightRobust for why this is better than LobePdf / (Pdf + LobePdf)
		float MISWeight;
		if (Pdf < LobePdf)
			MISWeight = 1 / (1 + Pdf / LobePdf);
		else if (LobePdf < Pdf)
			MISWeight = 1 - 1 / (1 + LobePdf / Pdf);
		else
			MISWeight = 0.5f; // avoid (rare) inf/inf

		Weight = lerp(Weight, LobeWeight, MISWeight);
		Pdf += LobePdf;
	}
}

// The following structs are used as return types for the Eval/Sample methods

struct FMaterialSample
{
	float3 Direction;
	float3 Weight;
	float Pdf;
	float PositionBiasSign;
	float Roughness;
};

FMaterialSample NullMaterialSample()
{
	// return a zero initialized sample, for cases where we couldn't sample the material (such as rays below the horizon, etc..)
	return (FMaterialSample)0;
}

FMaterialSample CreateMaterialSample(float3 Direction, float3 Weight, float Pdf, float PositionBiasSign, float Roughness)
{
	FMaterialSample Result;
	Result.Direction = Direction;
	Result.Weight = Weight;
	Result.Pdf = Pdf;
	Result.PositionBiasSign = PositionBiasSign;
	Result.Roughness = Roughness;
	return Result;
}

struct FMaterialEval
{
	float3 Weight;
	float Pdf;
};

FMaterialEval NullMaterialEval()
{
	return (FMaterialEval)0;
}

FMaterialEval CreateMaterialEval(float3 Weight, float Pdf)
{
	FMaterialEval Result;
	Result.Weight = Weight;
	Result.Pdf = Pdf;
	return Result;
}
