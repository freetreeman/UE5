// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "../Common.ush"
#include "HairStrandsVisibilityCommon.ush"

#define TILE_SIZE 8
#define GROUP_THREAD_COUNT (TILE_SIZE*TILE_SIZE)

////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_TILE_GENERATION
int2 ViewResolution;
Texture2D<uint4> InputTexture;
RWBuffer<uint> TileCountBuffer;
RWBuffer<uint2> TileDataBuffer;
RWBuffer<uint2> TileClearBuffer;

groupshared bool s_HasTileHair[GROUP_THREAD_COUNT];

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void TileMainCS(uint2 DispatchThreadId : SV_DispatchThreadID, uint LinearIndex : SV_GroupIndex, uint3 GroupId : SV_GroupID)
{
	const uint2 PixelCoord = DispatchThreadId;

	bool bHasHairData = false;
	if (all(PixelCoord < uint2(ViewResolution)))
	{
		const FCategorizationData CategorisationData = DecodeCategorizationData(InputTexture.Load(uint3(PixelCoord, 0)));
		bHasHairData = CategorisationData.PixelCoverage > 0.0f;
	}
	s_HasTileHair[LinearIndex] = bHasHairData;

	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 32)
	{
		s_HasTileHair[LinearIndex] = s_HasTileHair[LinearIndex] || s_HasTileHair[LinearIndex + 32];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 16)
	{
		s_HasTileHair[LinearIndex] = s_HasTileHair[LinearIndex] || s_HasTileHair[LinearIndex + 16];
	}
	GroupMemoryBarrierWithGroupSync();

	if (LinearIndex < 8)
	{
		s_HasTileHair[LinearIndex] = s_HasTileHair[LinearIndex] || s_HasTileHair[LinearIndex + 8];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 4)
	{
		s_HasTileHair[LinearIndex] = s_HasTileHair[LinearIndex] || s_HasTileHair[LinearIndex + 4];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 2)
	{
		s_HasTileHair[LinearIndex] = s_HasTileHair[LinearIndex] || s_HasTileHair[LinearIndex + 2];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 1)
	{
		if ((s_HasTileHair[LinearIndex] || s_HasTileHair[LinearIndex + 1]))
		{
			uint WriteToIndex;
			InterlockedAdd(TileCountBuffer[0], 1, WriteToIndex);
			TileDataBuffer[WriteToIndex] = GroupId.xy;
		}
		else
		{
			uint WriteToIndex;
			InterlockedAdd(TileCountBuffer[1], 1, WriteToIndex);
			TileClearBuffer[WriteToIndex] = GroupId.xy;
		}
	}
}
#endif // SHADER_TILE_GENERATION

////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_TILE_COPY_ARGS
uint2 TileCountXY;
uint  TilePerThread_GroupSize;
uint bRectPrimitive;
Buffer<uint> TileCountBuffer;
RWBuffer<uint> TileIndirectDrawBuffer;
RWBuffer<uint> TileIndirectDispatchBuffer;
RWBuffer<uint> TilePerThreadIndirectDispatchBuffer;
RWBuffer<uint> TileClearIndirectDrawBuffer;

[numthreads(1, 1, 1)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	if (all(DispatchThreadId == 0))
	{
		const uint TileCount = TileCountBuffer[0];

		// Indirect draw
		TileIndirectDrawBuffer[0] = bRectPrimitive > 0 ? 4 : 6;
		TileIndirectDrawBuffer[1] = TileCount;
		TileIndirectDrawBuffer[2] = 1;

		// Indirect dispatch
		TileIndirectDispatchBuffer[0] = TileCount % TileCountXY.x;
		TileIndirectDispatchBuffer[1] = (TileCount+TileCountXY.x-1) / TileCountXY.x;
		TileIndirectDispatchBuffer[2] = 1;

		// Indirect dispatch with one thread
		// At 4k, with 8x8 tiles: 4096 x 4096 / 8 x 8 = 512 x 512 tiles 
		// With a group size of 64 (8x8), the total dispatch count should be 512 x 512 / 8 x 8 = 64 x 64 = 4096, which is below the 65k limit per dimension
		TilePerThreadIndirectDispatchBuffer[0] = (TileCount + TilePerThread_GroupSize -1) / TilePerThread_GroupSize;
		TilePerThreadIndirectDispatchBuffer[1] = 1;
		TilePerThreadIndirectDispatchBuffer[2] = 1;

		const uint TileClearCount = TileCountBuffer[1];

		TileClearIndirectDrawBuffer[0] = bRectPrimitive > 0 ? 4 : 6;
		TileClearIndirectDrawBuffer[1] = TileClearCount;
		TileClearIndirectDrawBuffer[2] = 1;
	}
}
#endif // SHADER_TILE_COPY_ARGS

////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_TILE_DEBUG

void MainPS(
	in FScreenVertexOutput Input,
	out float4 OutColor0 : SV_Target0)
{
	const uint2 InTileCoord = uint2(Input.Position.xy) >> 3u; // TILE_SIZE == 8;
	const bool bTileX = (InTileCoord.x & 1) == 0;
	const bool bTileY = (InTileCoord.y & 1) == 0;
	const bool bChecker = (bTileX && bTileY) || (!bTileX && !bTileY);
	OutColor0 = 255;
	OutColor0 = bChecker ? float4(0.0f, 0.5f, 0.f, 1.0f) : float4(0.f, 1.0f, 0.f, 1.0f);
}

#endif //SHADER_TILE_DEBUG

////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_TILE_VS
int2 TileOutputResolution;
Buffer<uint2> TileDataBuffer;

void MainVS(
	in uint InVertexId : SV_VertexID,
	in uint InInstanceId : SV_InstanceID,
	out FScreenVertexOutput Out)
{
	Out = (FScreenVertexOutput)0;
	const uint2 TileCoord = TileDataBuffer[InInstanceId];

	uint2 TileVertex = TileCoord * TILE_SIZE;
	TileVertex.x += InVertexId == 1 || InVertexId == 2 || InVertexId == 4 ? TILE_SIZE : 0;
	TileVertex.y += InVertexId == 2 || InVertexId == 4 || InVertexId == 5 ? TILE_SIZE : 0;
	Out.UV = float2(TileVertex) / float2(TileOutputResolution);
	Out.Position = float4(Out.UV * float2(2.0f, -2.0f) + float2(-1.0, 1.0f), 0.5f, 1.0f);
}

#endif //SHADER_TILE_VS
