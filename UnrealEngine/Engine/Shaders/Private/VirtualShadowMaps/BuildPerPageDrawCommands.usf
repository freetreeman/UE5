// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	BuildPerPageDrawCommands.usf.usf: 
=============================================================================*/

#include "../Common.ush"
#include "PageOverlap.ush"
#include "ProjectionCommon.ush"
#include "../Nanite/NaniteDataDecode.ush"
#include "../InstanceCulling/InstanceCullingCommon.ush"
#include "../WaveOpUtil.ush"

#ifndef NEAR_CLIP
#define NEAR_CLIP 1
#endif

// Stored in an unordered fashion, needs to be reorganized later
struct FVisibleInstanceCmd
{
	uint PackedPageInfo;
	uint InstanceId;
	uint DrawCommandId;
};

uint PackPageInfo(FPageInfo PageInfo)
{
	// TODO: Why not do address translation here? Physical pages need fewer bits.
	uint4 PackedData = 0U;
	uint BitPos = 0U;
	WriteBits(PackedData, BitPos, PageInfo.VirtualPage.x, VSM_LOG2_LEVEL0_DIM_PAGES_XY);
	WriteBits(PackedData, BitPos, PageInfo.VirtualPage.y, VSM_LOG2_LEVEL0_DIM_PAGES_XY);
	WriteBits(PackedData, BitPos, PageInfo.ViewId, VSM_PACKED_PAGE_INFO_VIEW_ID_BITS);
	WriteBits(PackedData, BitPos, PageInfo.SuperPageLevel, VSM_PACKED_PAGE_INFO_SUPER_PAGE_LEVEL_BITS);

	return PackedData.x;
}


RWStructuredBuffer<FVisibleInstanceCmd> VisibleInstancesOut;
StructuredBuffer<uint> InstanceIdsBuffer;
StructuredBuffer<uint> DrawCommandIdsBuffer;
StructuredBuffer<uint> NumInstanceIdsBuffer;
uint FirstPrimaryView;
uint NumPrimaryViews;
RWStructuredBuffer<uint> DrawCommandInstanceCountBufferOut;
RWStructuredBuffer<uint> VisibleInstanceCountBufferOut;
uint InstanceSceneDataSOAStride;
uint bInstancePerPage;

RWStructuredBuffer<uint> OutDynamicCasterFlags;
StructuredBuffer<FPrimCullingCommand> PrimitiveCullingCommands;


void WriteCmd(uint2 VirtualPage, uint MipViewId, uint InstanceId, uint DrawCommandId)
{
	FPageInfo PageInfo;
	PageInfo.VirtualPage = VirtualPage;
	PageInfo.ViewId = MipViewId;
	PageInfo.SuperPageLevel = 0U;

	FVisibleInstanceCmd VisibleInstanceCmd;
	VisibleInstanceCmd.PackedPageInfo = PackPageInfo(PageInfo);
	VisibleInstanceCmd.InstanceId = InstanceId;
	VisibleInstanceCmd.DrawCommandId = DrawCommandId;

	uint VisibleInstanceOutputOffset = 0U;
	WaveInterlockedAddScalar_(VisibleInstanceCountBufferOut[0], 1U, VisibleInstanceOutputOffset);
	VisibleInstancesOut[VisibleInstanceOutputOffset] = VisibleInstanceCmd;
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CullPerPageDrawCommandsCs(uint InstanceIdIndex : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
{
	// Produced by previous passes
	uint NumInstances = NumInstanceIdsBuffer[0];

	if (NumInstances == 0)
	{
		return;
	}

	if (InstanceIdIndex >= NumInstances)
	{
		return;
	}

	// Load the offset (produced by the previous pass on GPU) or maybe use a fresh/recycled buffer for each and set to zero?
	uint InstanceIdOffset = 0;//InstanceIdsOffsetBuffer[BaseOffset];
	uint InstanceId = InstanceIdsBuffer[InstanceIdOffset + InstanceIdIndex] & ((1U << 28U) - 1);
	// Do we need this? Probably for virtual cube maps if we get there.
	uint ViewIdIndex = InstanceIdsBuffer[InstanceIdOffset + InstanceIdIndex] >> 28U;
	uint DrawCommandId = DrawCommandIdsBuffer[InstanceIdOffset + InstanceIdIndex];

	const bool bNearClip = (NEAR_CLIP != 0);
	FPrimCullingCommand Cmd = PrimitiveCullingCommands[DrawCommandId];

	// Load relevant instance data
	FInstanceSceneData InstanceData = GetInstanceSceneData(InstanceId, InstanceSceneDataSOAStride);
	const bool bHasMoved = GetGPUSceneFrameNumber() == InstanceData.LastUpdateSceneFrameNumber || Cmd.bMaterialMayModifyPosition;
	const uint PageFlagMask = bHasMoved ? VSM_ALLOCATED_FLAG : VSM_INVALID_FLAG;

	uint ThreadTotalForAllViews = 0;
#if LOOP_OVER_VIEWS
	// Loop over views and output visible instance (i.e., those that overlap a valid page)
	for (uint PrimaryViewId = FirstPrimaryView; PrimaryViewId < FirstPrimaryView + NumPrimaryViews; ++PrimaryViewId)
#else
	uint PrimaryViewId = ViewIdIndex;
#endif
	{
		FNaniteView NaniteView = GetNaniteView(PrimaryViewId);
		const uint2 TargetViewSize = uint2(NaniteView.ViewSizeAndInvSize.xy);

		float4x4 LocalToTranslatedWorld = InstanceData.LocalToWorld;
		LocalToTranslatedWorld[3].xyz += NaniteView.PreViewTranslation.xyz;
		float4x4 LocalToClip = mul(LocalToTranslatedWorld, NaniteView.TranslatedWorldToClip);

		FFrustumCullData Cull = BoxCullFrustum(InstanceData.LocalBoundsCenter, InstanceData.LocalBoundsExtent, LocalToClip, bNearClip, false);

		if (Cull.bIsVisible)
		{
			// Loop over mip levels and count number of output visible instances, also retain a bit for each mip level (used to skip empty levels in output loop)
			for (uint MipLevel = 0; MipLevel < uint(NaniteView.TargetNumMipLevels); ++MipLevel)
			{
				uint MipViewId = MipLevel * NumPrimaryViews + PrimaryViewId;
				FNaniteView MipView = GetNaniteView(MipViewId);
				uint VirtualShadowMapId = uint(MipView.TargetLayerIndex);

				FScreenRect Rect = GetScreenRect(MipView.ViewRect, Cull, 4);

				if (OverlapsAnyValidPage(VirtualShadowMapId, MipLevel, MipView.ViewRect.xy, Rect, bHasMoved))
				{
					uint4 RectPages = uint4( MipView.ViewRect.xyxy + Rect.Pixels ) >> VSM_LOG2_PAGE_SIZE;

					// Clip to actually allocated pages
					// TODO: move this to be done as part of or before the overlap test?
					uint4 AllocatedBounds = PageRectBounds[VirtualShadowMapId * VSM_MAX_MIP_LEVELS + MipLevel];
					RectPages.xy = max(RectPages.xy, AllocatedBounds.xy);
					RectPages.zw = min(RectPages.zw, AllocatedBounds.zw);
					if (all(RectPages.zw >= RectPages.xy))
					{
						if (bInstancePerPage)
						{
							// Count commands for each overlapped page
							uint PageTableLevelOffset = CalcPageTableLevelOffset(VirtualShadowMapId, MipLevel);
							for (uint y = RectPages.y; y <= RectPages.w; y += 1U)
							{
								for (uint x = RectPages.x; x <= RectPages.z; x += 1U)
								{
									uint PageFlagOffset = PageTableLevelOffset + CalcPageOffsetInLevel(MipLevel, uint2(x, y));
									uint PageFlag = PageFlags[PageFlagOffset];

									if ((PageFlag & PageFlagMask) != 0)
									{
										++ThreadTotalForAllViews;
										WriteCmd(uint2(x,y), MipViewId, InstanceId, DrawCommandId);

										if (bHasMoved)
										{
											OutDynamicCasterFlags[PageFlagOffset] = 1;
										}
									}
								}
							}
						}
						else
						{
							// bInstancePerPage just one per rect
							++ThreadTotalForAllViews;
							WriteCmd(RectPages.xy, MipViewId, InstanceId, DrawCommandId);
							if (bHasMoved)
							{
								uint PageTableLevelOffset = CalcPageTableLevelOffset(VirtualShadowMapId, MipLevel);
								for (uint y = RectPages.y; y <= RectPages.w; y += 1U)
								{
									for (uint x = RectPages.x; x <= RectPages.z; x += 1U)
									{
										uint PageFlagOffset = PageTableLevelOffset + CalcPageOffsetInLevel(MipLevel, uint2(x, y));
										uint PageFlag = PageFlags[PageFlagOffset];

										if ((PageFlag & PageFlagMask) != 0)
										{
											OutDynamicCasterFlags[PageFlagOffset] = 1;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// Accumulate total number of instances/page pairs for each draw command, is used to allocate space and output compact range of instances later
	InterlockedAdd(DrawCommandInstanceCountBufferOut[DrawCommandId], ThreadTotalForAllViews);
}

RWBuffer<uint> DrawIndirectArgsBufferOut;
RWBuffer<uint> InstanceIdOffsetBufferOut;
RWStructuredBuffer<uint> OutputOffsetBufferOut;
RWStructuredBuffer<uint> TmpInstanceIdOffsetBufferOut;
StructuredBuffer<uint> DrawCommandInstanceCountBuffer;

uint NumDrawCommands;
/**
 * Separate pass to allocate space, needs to run once the final space requirements are known. We buffer the page/instance-draw info and reshuffle later.
 * TODO: Possibly just re-run the culling process in the output pass, saves storing stuff, but may cost more and runs the risk of the passes disagreeing e.g., due to rounding or whatever.
 */
[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void AllocateCommandInstanceOutputSpaceCs(uint DrawCommandId : SV_DispatchThreadID)
{
	if (DrawCommandId < NumDrawCommands)
	{
		uint CommandInstanceCount = DrawCommandInstanceCountBuffer[DrawCommandId];
		uint CommandInstanceOffset = 0U;
		if (CommandInstanceCount > 0U)
		{
			InterlockedAdd(OutputOffsetBufferOut[0], CommandInstanceCount, CommandInstanceOffset);
		}
		InstanceIdOffsetBufferOut[DrawCommandId] = CommandInstanceOffset;
		// Store second copy for use during output pass (as we need the first offset buffer during the actual rendering)
		TmpInstanceIdOffsetBufferOut[DrawCommandId] = CommandInstanceOffset;
		
		// fix up the instance count of the draw command (the rest is filled in earlier):
		DrawIndirectArgsBufferOut[DrawCommandId * INDIRECT_ARGS_NUM_WORDS + 1] = CommandInstanceCount;
	}

	// Also set up indirect dispatch args for the output pass (OutputCommandInstanceLists)
	//if (DrawCommandId == 0)
	//{
	//	uint NumVisibleInstances = VisibleInstanceCountBuffer[0];
	//	// ...dispatch args to process all the visible instances
	//}
}

StructuredBuffer<FVisibleInstanceCmd> VisibleInstances;
StructuredBuffer <uint> VisibleInstanceCountBuffer;
//RWStructuredBuffer<uint> TmpInstanceIdOffsetBufferOut;
RWStructuredBuffer<uint> InstanceIdsBufferOut;
RWStructuredBuffer<uint> PageInfoBufferOut;


[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void OutputCommandInstanceListsCs(uint VisibleInstanceIndex : SV_DispatchThreadID)
{
	uint NumVisibleInstances = VisibleInstanceCountBuffer[0];

	if (VisibleInstanceIndex < NumVisibleInstances)
	{
		FVisibleInstanceCmd VisibleInstanceCmd = VisibleInstances[VisibleInstanceIndex];

		// Scatter the instance ID & other data.
		uint InstanceIdOutputOffset = 0;
		InterlockedAdd(TmpInstanceIdOffsetBufferOut[VisibleInstanceCmd.DrawCommandId], 1U, InstanceIdOutputOffset);
		// TODO: maybe repack as uint2 since that might be better for these type of presumably scalar loads.
		InstanceIdsBufferOut[InstanceIdOutputOffset] = VisibleInstanceCmd.InstanceId;
		PageInfoBufferOut[InstanceIdOutputOffset] = VisibleInstanceCmd.PackedPageInfo;
	}
}