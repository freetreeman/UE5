// Copyright Epic Games, Inc. All Rights Reserved.

#include "ModelingObjectsCreationAPI.h"
#include "InteractiveToolManager.h"
#include "ContextObjectStore.h"

#include "Misc/Paths.h"
#include "Components/StaticMeshComponent.h"
#include "Engine/StaticMesh.h"



void FCreateMeshObjectParams::SetMesh(FMeshDescription&& MeshDescriptionIn)
{
	MeshDescription = MoveTemp(MeshDescriptionIn);
	MeshType = ECreateMeshObjectSourceMeshType::MeshDescription;
}

void FCreateMeshObjectParams::SetMesh(const UE::Geometry::FDynamicMesh3* DynamicMeshIn)
{
	DynamicMesh = *DynamicMeshIn;
	MeshType = ECreateMeshObjectSourceMeshType::DynamicMesh;
}

void FCreateMeshObjectParams::SetMesh(UE::Geometry::FDynamicMesh3&& DynamicMeshIn)
{
	DynamicMesh = MoveTemp(DynamicMeshIn);
	MeshType = ECreateMeshObjectSourceMeshType::DynamicMesh;
}







FCreateMeshObjectResult UE::Modeling::CreateMeshObject(UInteractiveToolManager* ToolManager, FCreateMeshObjectParams&& CreateMeshParams)
{
	if (ensure(ToolManager))
	{
		UModelingObjectsCreationAPI* UseAPI = ToolManager->GetContextObjectStore()->FindContext<UModelingObjectsCreationAPI>();
		if (UseAPI)
		{
			if (UseAPI->HasMoveVariants())
			{
				return UseAPI->CreateMeshObject(MoveTemp(CreateMeshParams));
			}
			else
			{
				return UseAPI->CreateMeshObject(CreateMeshParams);
			}
		}
	}
	return FCreateMeshObjectResult{ ECreateModelingObjectResult::Failed_NoAPIFound };
}





FCreateTextureObjectResult UE::Modeling::CreateTextureObject(UInteractiveToolManager* ToolManager, FCreateTextureObjectParams&& CreateTexParams)
{
	if (ensure(ToolManager))
	{
		UModelingObjectsCreationAPI* UseAPI = ToolManager->GetContextObjectStore()->FindContext<UModelingObjectsCreationAPI>();
		if (UseAPI)
		{
			if (UseAPI->HasMoveVariants())
			{
				return UseAPI->CreateTextureObject(MoveTemp(CreateTexParams));
			}
			else
			{
				return UseAPI->CreateTextureObject(CreateTexParams);
			}
		}
	}
	return FCreateTextureObjectResult{ ECreateModelingObjectResult::Failed_NoAPIFound };
}







FString UE::Modeling::GetComponentAssetBaseName(UPrimitiveComponent* Component, bool bRemoveAutoGeneratedSuffixes)
{
	if (!ensure(Component != nullptr))
	{
		return TEXT("InvalidComponent");
	}

	FString ResultName = Component->GetName();
	if (bRemoveAutoGeneratedSuffixes)
	{
		ResultName = UE::Modeling::StripGeneratedAssetSuffixFromName(ResultName);
	}

	// handle static meshcomponents
	UStaticMeshComponent* StaticMeshComponent = Cast<UStaticMeshComponent>(Component);
	if (StaticMeshComponent != nullptr)
	{
		UStaticMesh* SourceMesh = StaticMeshComponent->GetStaticMesh();
		if (SourceMesh)
		{
			FString AssetName = FPaths::GetBaseFilename(SourceMesh->GetName());
			ResultName = (bRemoveAutoGeneratedSuffixes) ? UE::Modeling::StripGeneratedAssetSuffixFromName(AssetName) : AssetName;
		}
	}

	return ResultName;
}




FString UE::Modeling::StripGeneratedAssetSuffixFromName(FString InputName)
{
	// find final '_'
	int32 Index;
	if (!InputName.FindLastChar('_', Index))
	{
		return InputName;
	}
	// check that remaining characters are hex digits (from UUID)
	int32 Len = InputName.Len();
	int32 Count = 0, Letters = 0, Numbers = 0;
	for (int32 k = Index + 1; k < Len; ++k)
	{
		if (FChar::IsHexDigit(InputName[k]) == false)
		{
			return InputName;
		}
		Count++;
		if (FChar::IsDigit(InputName[k]))
		{
			Numbers++;
		}
		else
		{
			Letters++;
		}
	}
	// currently assuming appended UUID is at least 8 characters
	if (Numbers == 0 || Letters == 0 || Count < 8)
	{
		return InputName;
	}

	return InputName.Left(Index);
}
